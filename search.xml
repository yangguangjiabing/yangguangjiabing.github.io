<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>在 Mac 下安装并使用 Redis</title>
      <link href="2017/05/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%9C%A8Mac%E4%B8%8B%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8Redis/"/>
      <url>2017/05/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%9C%A8Mac%E4%B8%8B%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8Redis/</url>
      
        <content type="html"><![CDATA[<p>在 Mac 下安装并使用 Redis 的记录</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>使用 Homebrew 安装</li><li>使用 curl 安装</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>启动服务器<br>/usr/local/bin/redis-server</p></li><li><p>启动客户端<br>redis-cli // /usr/local/bin 下</p></li></ol><p>which redis-server 查看位置</p><h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解 PHP7</title>
      <link href="2017/05/11/PHP/%E4%BA%86%E8%A7%A3PHP7/"/>
      <url>2017/05/11/PHP/%E4%BA%86%E8%A7%A3PHP7/</url>
      
        <content type="html"><![CDATA[<p>认识 PHP 7 中的新特性<br>在 PHP 7.0 和 7.1 版本中，分别有着不同的变化。</p><a id="more"></a><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><h3 id="标量类型声明"><a href="#标量类型声明" class="headerlink" title="标量类型声明"></a>标量类型声明</h3><blockquote><p>可以使用下列类型参数（无论用强制模式还是严格模式）： 字符串(string), 整数 (int), 浮点数 (float), 以及布尔值 (bool)。</p></blockquote><h3 id="返回值类型声明"><a href="#返回值类型声明" class="headerlink" title="返回值类型声明"></a>返回值类型声明</h3><blockquote><p>返回类型声明指明了函数返回值的类型。可用的类型与参数声明中可用的类型相同。</p></blockquote><h3 id="null合并运算符"><a href="#null合并运算符" class="headerlink" title="null合并运算符(??)"></a>null合并运算符(??)</h3><blockquote><p>null合并运算符 (??) 如果变量存在且值不为NULL， 它就会返回自身的值，否则返回它的第二个操作数。</p></blockquote><h3 id="太空船操作符（组合比较符）"><a href="#太空船操作符（组合比较符）" class="headerlink" title="太空船操作符（组合比较符）"></a>太空船操作符（组合比较符）</h3><blockquote><p>当$a小于、等于或大于$b时它分别返回-1、0或1。 比较的原则是沿用 PHP 的常规比较规则进行的。</p></blockquote><h3 id="通过-define-定义常量数组"><a href="#通过-define-定义常量数组" class="headerlink" title="通过 define() 定义常量数组"></a>通过 define() 定义常量数组</h3><h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h3><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ol><li>如何进行性能分析？</li><li>PHP 开发游戏</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://segmentfault.com/a/1190000003893899">HP7新特性的介绍</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP会话管理</title>
      <link href="2017/05/10/PHP/PHP%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/"/>
      <url>2017/05/10/PHP/PHP%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>Cookie：是一种在远程浏览器端储存数据并以此来跟踪和识别用户的机制<br>Seesion：记录在服务器</p><a id="more"></a><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="设置-Cookie"><a href="#设置-Cookie" class="headerlink" title="设置 Cookie"></a>设置 Cookie</h3><ol><li>使用 setcookie()</li><li>使用 header()</li></ol><h3 id="读取-Cookie"><a href="#读取-Cookie" class="headerlink" title="读取 Cookie"></a>读取 Cookie</h3><ol><li>使用 <code>$_COOKIE</code> 全局变量</li></ol><h3 id="删除-Cookie"><a href="#删除-Cookie" class="headerlink" title="删除 Cookie"></a>删除 Cookie</h3><ol><li>设置过期时间</li></ol><p>JS 读取 cookie : gocument.cookie</p><p>session_start() // 启动 Seesion</p><p>header(“Localhost:地址”) // 跳转</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.cnblogs.com/CraryPrimitiveMan/p/3687621.html">PHP 的学习–cookie 和 seesion</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Session </tag>
            
            <tag> Cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法 归并排序</title>
      <link href="2017/04/27/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>2017/04/27/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-栈</title>
      <link href="2017/04/26/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
      <url>2017/04/26/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>栈（stack）是限定仅在表尾进行插入或删除操作的线性表。表尾端称为<strong>栈顶</strong>（top），表头端称为<strong>栈底</strong>（bottom）。不含元素的空表称为<strong>空栈</strong>。栈是后进先出（LIFO, Last In First Out）的线性表。</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-队列</title>
      <link href="2017/04/26/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/"/>
      <url>2017/04/26/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>队列，又称为伫列（queue），是一种<strong>先进先出</strong>（FIFO, First-In-First-Out）的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在<strong>队尾</strong>（称为rear）进行插入操作，在<strong>对头</strong>（称为front）进行删除操作。</p><a id="more"></a><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97">维基百科-队列</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel 自定义中间件</title>
      <link href="2017/04/26/PHP/laravel-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>2017/04/26/PHP/laravel-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<!-- TODO --><p>TODO</p><a id="more"></a><p><a href="http://www.jb51.net/article/94271.htm">http://www.jb51.net/article/94271.htm</a></p><p>参考</p><ul><li><a href="http://d.laravel-china.org/docs/5.4/middleware#defining-middleware">Laravel 的路由中间件</a></li><li><a href="https://segmentfault.com/q/1010000007040507">laravel在中间件内生成的变量如何传到控制器</a></li><li><a href="http://blog.csdn.net/sinat_21158419/article/details/53168027"> Laravel 5如何在中间件中获取路由参数？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
            <tag> php </tag>
            
            <tag> 未完成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法 堆排序</title>
      <link href="2017/04/24/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>2017/04/24/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel-自定义常量</title>
      <link href="2017/04/24/PHP/larave-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F/"/>
      <url>2017/04/24/PHP/larave-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>在 laravel 中自定义常量的方式：</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><ol><li><p>定义<br>在 <code>app/config</code> 下新建一个 <code>php</code> 文件，如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="comment">// app/config/demo.php</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">      <span class="string">&#x27;NAME&#x27;</span> =&gt; <span class="string">&#x27;val&#x27;</span></span><br><span class="line">  ];</span><br></pre></td></tr></table></figure></li><li><p>使用<br>在任意文件中直接使用 <code>config</code> 辅助函数获取你的设置值</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// routes/web.php</span></span><br><span class="line"></span><br><span class="line">Route::get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> config(<span class="string">&#x27;demo.NAME&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a></li></ol><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>很多时候我们需要用到常量，那么怎么在laravel定义常量呢，有以下几种：</p><ol><li><p>在app/constants.php(手动创建文件)里定义纯PHP常量</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">&#x27;ADMIN&#x27;</span>, <span class="string">&#x27;administrator&#x27;</span>);</span><br></pre></td></tr></table></figure><p>然后在app/bootstrap/autolad.php：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="keyword">__DIR__</span>.<span class="string">&#x27;/../app/functions.php&#x27;</span>; <span class="comment">//引入自定义常量文件</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2></li></ol><ul><li><a href="https://ilongx.com/article/6">laravel 自定义常量方法</a></li><li><a href="http://www.emptyrealm.com/laravel%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F/">laravel自定义常量</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法-快速排序</title>
      <link href="2017/04/22/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>2017/04/22/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>在平均状况下，排序n个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n)算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><a id="more"></a><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。</p><ol><li>从数列中挑出一个元素，称为”基准”（pivot），</li><li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function quicksort(q)</span><br><span class="line">&#123;</span><br><span class="line">  var list less, pivotList, greater</span><br><span class="line">  if length(q) ≤ 1 &#123;</span><br><span class="line">      return q</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      select a pivot value pivot from q</span><br><span class="line">      for each x in q except the pivot element</span><br><span class="line">          if x &lt; pivot then add x to less</span><br><span class="line">          if x ≥ pivot then add x to greater</span><br><span class="line">      add pivot to pivotList</span><br><span class="line">      return concatenate(quicksort(less), pivotList, quicksort(greater))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="范例程式码"><a href="#范例程式码" class="headerlink" title="范例程式码"></a>范例程式码</h2><p>  <strong>PHP：</strong><br>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><ul><li>数据结构：数组</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">维基百科 | 快速排序</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法-选择排序</title>
      <link href="2017/04/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>2017/04/20/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p><a id="more"></a><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>n 个元素的数组的直接选择排序可经过n-1趟直接选择排序得到有序结果：</p><ol><li>第一趟遍历，从 n 个元素中选择最小（或最大）元素，与第一个元素交换</li><li>第二趟，从剩下的 n-1 个元素中，找出最小（或最大）元素，与第二个元素交换</li><li>第 i 趟，从剩下的 n-1-i 个元素中，找出最小（或最大）元素，与第 i 个元素交换</li></ol><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function selection_sort(array, length) &#123;</span><br><span class="line">for (i &#x3D; 0 to len - 1) &#123;</span><br><span class="line">min &#x3D; i;</span><br><span class="line">for (j &#x3D; i + 1 to len)</span><br><span class="line">if (arr[min] &gt; arr[j])</span><br><span class="line">min &#x3D; j;</span><br><span class="line"></span><br><span class="line">      swap(arr[min], arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="范例程式码"><a href="#范例程式码" class="headerlink" title="范例程式码"></a>范例程式码</h2><p>  <strong>PHP：</strong><br>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selection_sort</span>(<span class="params">&amp;<span class="variable">$arr</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; count(<span class="variable">$arr</span>) - <span class="number">1</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line"><span class="variable">$min</span> = <span class="variable">$i</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$j</span> = <span class="variable">$i</span> + <span class="number">1</span>; <span class="variable">$j</span> &lt; count(<span class="variable">$arr</span>); <span class="variable">$j</span>++)</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$arr</span>[<span class="variable">$min</span>] &gt; <span class="variable">$arr</span>[<span class="variable">$j</span>])</span><br><span class="line"><span class="variable">$min</span> = <span class="variable">$j</span>;</span><br><span class="line"></span><br><span class="line">swap(<span class="variable">$arr</span>[<span class="variable">$min</span>], <span class="variable">$arr</span>[<span class="variable">$i</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">&amp;<span class="variable">$x</span>, &amp;<span class="variable">$y</span></span>) </span>&#123;</span><br><span class="line">  <span class="variable">$t</span> = <span class="variable">$x</span>;</span><br><span class="line">  <span class="variable">$x</span> = <span class="variable">$y</span>;</span><br><span class="line">  <span class="variable">$y</span> = <span class="variable">$t</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><ul><li>数据结构：数组</li><li>时间复杂度：O(n²)</li><li>最优时间复杂度    О(n²)</li><li>平均时间复杂度    О(n²)</li><li>空间复杂度    О(n) total, O(1) auxiliary</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">维基百科 | 选择排序</a></li><li><a href="http://blog.csdn.net/cjf_iceking/article/details/7914554">选择排序</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法-插入排序</title>
      <link href="2017/04/07/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>2017/04/07/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><a id="more"></a><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>一般来说，插入排序都采用 <strong>原地算法</strong> 在数组上实现。具体算法描述如下：</p><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤2~5</li></ol><p>如果比较操作的代价比交换操作大的话，可以采用 <em>二分查找法</em> 来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为 <em>二分查找插入排序</em> 。</p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insertion_sort(array, length)</span><br><span class="line">&#123;</span><br><span class="line">  for i &#x3D; 1 to length - 1</span><br><span class="line">    for j &#x3D; 0 to i - 1</span><br><span class="line">      if(array[j] &gt; array[i]])</span><br><span class="line">        swap[array[j], array[i]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="范例程式码"><a href="#范例程式码" class="headerlink" title="范例程式码"></a>范例程式码</h2><p><strong>PHP：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertion_sort</span>(<span class="params">&amp;<span class="variable">$arr</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">1</span>; <span class="variable">$i</span> &lt; count(<span class="variable">$arr</span>); <span class="variable">$i</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="variable">$temp</span> = <span class="variable">$arr</span>[<span class="variable">$i</span>];</span><br><span class="line">     <span class="keyword">for</span> (<span class="variable">$j</span> = <span class="variable">$i</span> - <span class="number">1</span>; <span class="variable">$j</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="variable">$arr</span>[<span class="variable">$j</span>] &gt; <span class="variable">$temp</span>; <span class="variable">$j</span>--)</span><br><span class="line">     <span class="variable">$arr</span>[<span class="variable">$j</span> + <span class="number">1</span>] = <span class="variable">$arr</span>[<span class="variable">$j</span>];</span><br><span class="line">     <span class="variable">$arr</span>[<span class="variable">$j</span> + <span class="number">1</span>] = <span class="variable">$temp</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">维基百科 | 插入排序</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地算法（in-place algorithm）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
